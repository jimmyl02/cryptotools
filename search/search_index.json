{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Welcome to cryptotools ! Cryptotools is a repository / package which aims to simplify cryptography attacks by providing implementations for common utilities and attacks. This website documents how to use the crytotools library. Installation Installation is as simple as cloning the repository somewhere. cd /home/jimmy/ctf/tools git clone https://github.com/jimmyl02/cryptotools.git Usage The library must then be imported at the start of the Python or Sage file. import sys sys . path . insert ( 1 , '/home/jimmy/ctf/tools' ) from cryptotools import * # This must come after pwntools import Notes about Sage Some functions require sage and will silently not import if sage is not detected. These functions will have (Requires Sage) in the title. Additionally, the functions writen in sage will be prefixed with sage_*. They must be preparsed with sage --preparse {filename} then moved from {filename}.sage.py to {filename}.py . Hopefully there will be a script soon to do this automatically","title":"Home"},{"location":"#home","text":"Welcome to cryptotools ! Cryptotools is a repository / package which aims to simplify cryptography attacks by providing implementations for common utilities and attacks. This website documents how to use the crytotools library.","title":"Home"},{"location":"#installation","text":"Installation is as simple as cloning the repository somewhere. cd /home/jimmy/ctf/tools git clone https://github.com/jimmyl02/cryptotools.git","title":"Installation"},{"location":"#usage","text":"The library must then be imported at the start of the Python or Sage file. import sys sys . path . insert ( 1 , '/home/jimmy/ctf/tools' ) from cryptotools import * # This must come after pwntools import","title":"Usage"},{"location":"#notes-about-sage","text":"Some functions require sage and will silently not import if sage is not detected. These functions will have (Requires Sage) in the title. Additionally, the functions writen in sage will be prefixed with sage_*. They must be preparsed with sage --preparse {filename} then moved from {filename}.sage.py to {filename}.py . Hopefully there will be a script soon to do this automatically","title":"Notes about Sage"},{"location":"utilities/","text":"Utilities Default imports When solving crpytography tasks, there are common libraries which needs to be imported, cryptotools imports these by default as apart of utilities. The below list are the currently imported packages. Crypto.Util.number binascii.hexlify binascii.unhexlify Least Common Multiple (LCM) Solves for the least common multiple of two numbers. Arguments: a:integer, b:integer Returns: integer Example usage >>> LCM ( 123 , 12 ) 492 Xor Takes input bytestrings and xors all arguments with each other. Input must be same length or there will be an error. Arguments: *bytestring Returns: bytes of xored data Example usage >>> xor ( b ' \\x10\\x11\\x12 ' , 'abc' . encode ()) b 'qsq' Repeated Xor Repeatedly xors key against input bytestring. Arguments: inp_str:bytestring, key:bytestring Returns: bytes of xored data Example usage >>> repXor ( 'abcdefg' . encode (), 'key' . encode ()) b ' \\n\\x07\\x1a\\x0f\\x00\\x1f\\x0c ' Extended GCD Function which solves the extended GCD problem, a*u + b*v = gcd(a, b) , for u,v when given a,b. Arguments: a:integer, b:integer Returns: integer, integer, integer (gcd, u, v) Example usage >>> eGCD ( 15 , 26 ) ( 1 , 7 , - 4 ) Legendre Symbol Calculates the result of the legendre symbol, (a/p)=a^((p-1)/2) mod p , which can be used to determine whether a number is a quadratic residue. Arguments: a:integer, p:integer Returns: integer [1: a is quadratic residue, -1: a is quadratic non-residue, 0: a % p == 0] Example usage >>> legendre ( 28 , 3 ) 1 Chinese Remainder Theorem Solves system of congruences using the chinese remainder theorem. Algorithm explanation can be found here . Arguments: a:[integer], b:[integer]; follows x=a mod n where n_i must be coprime Returns: integer which is solution to system of congruences Example usage >>> crt ([ 1 , 4 , 6 ], [ 3 , 5 , 7 ]) 34","title":"Utilities"},{"location":"utilities/#utilities","text":"","title":"Utilities"},{"location":"utilities/#default-imports","text":"When solving crpytography tasks, there are common libraries which needs to be imported, cryptotools imports these by default as apart of utilities. The below list are the currently imported packages. Crypto.Util.number binascii.hexlify binascii.unhexlify","title":"Default imports"},{"location":"utilities/#least-common-multiple-lcm","text":"Solves for the least common multiple of two numbers. Arguments: a:integer, b:integer Returns: integer Example usage >>> LCM ( 123 , 12 ) 492","title":"Least Common Multiple (LCM)"},{"location":"utilities/#xor","text":"Takes input bytestrings and xors all arguments with each other. Input must be same length or there will be an error. Arguments: *bytestring Returns: bytes of xored data Example usage >>> xor ( b ' \\x10\\x11\\x12 ' , 'abc' . encode ()) b 'qsq'","title":"Xor"},{"location":"utilities/#repeated-xor","text":"Repeatedly xors key against input bytestring. Arguments: inp_str:bytestring, key:bytestring Returns: bytes of xored data Example usage >>> repXor ( 'abcdefg' . encode (), 'key' . encode ()) b ' \\n\\x07\\x1a\\x0f\\x00\\x1f\\x0c '","title":"Repeated Xor"},{"location":"utilities/#extended-gcd","text":"Function which solves the extended GCD problem, a*u + b*v = gcd(a, b) , for u,v when given a,b. Arguments: a:integer, b:integer Returns: integer, integer, integer (gcd, u, v) Example usage >>> eGCD ( 15 , 26 ) ( 1 , 7 , - 4 )","title":"Extended GCD"},{"location":"utilities/#legendre-symbol","text":"Calculates the result of the legendre symbol, (a/p)=a^((p-1)/2) mod p , which can be used to determine whether a number is a quadratic residue. Arguments: a:integer, p:integer Returns: integer [1: a is quadratic residue, -1: a is quadratic non-residue, 0: a % p == 0] Example usage >>> legendre ( 28 , 3 ) 1","title":"Legendre Symbol"},{"location":"utilities/#chinese-remainder-theorem","text":"Solves system of congruences using the chinese remainder theorem. Algorithm explanation can be found here . Arguments: a:[integer], b:[integer]; follows x=a mod n where n_i must be coprime Returns: integer which is solution to system of congruences Example usage >>> crt ([ 1 , 4 , 6 ], [ 3 , 5 , 7 ]) 34","title":"Chinese Remainder Theorem"},{"location":"RSA/attacks/","text":"RSA Attacks Wiener's Attack Implmentation of wiener's attack which is viable when d < N^(1/4). Another indiciation to attempt this attack is if e is large. Arguments: n:integer, e:integer Returns: integer, integer, integer (d, p, q) Example usage: # This problem is Super Safe RSA 2 from PicoCTF >>> n = 77531969503748326589677418948315140870584015245386763633241518845356850979564402923266696704186567270006361208862086254527576010412135230279553684940635956656649728134893874567619948675304052482720430367748612708917105846534082863042823913166120865362252479206576942147071396319459112580853771742537940112457 >>> e = 56172436577459725698934391359139104915041430213184221292301658571726414059411889155782982024019814564512291421932489731563519296372873415080546379424619308859152360214209740169135159761234894923144971372974038021945201954600238994209605035703317119192844975463915465725406543097929017637859019950590916533609 >>> RSA . wiener_attack ( n , e ) ( 65537 , 7378976741566796197060049293831700178355367285954368722446941408821453416404178156616347704608205580844317832893779999699977892594442209725444425740109323 , 10507143770626084625372769867908090388836545006827124055843791486155727314389374863050474785111869163080974026305280302634065146526795980161236365076948859 )","title":"Attacks"},{"location":"RSA/attacks/#rsa-attacks","text":"","title":"RSA Attacks"},{"location":"RSA/attacks/#wieners-attack","text":"Implmentation of wiener's attack which is viable when d < N^(1/4). Another indiciation to attempt this attack is if e is large. Arguments: n:integer, e:integer Returns: integer, integer, integer (d, p, q) Example usage: # This problem is Super Safe RSA 2 from PicoCTF >>> n = 77531969503748326589677418948315140870584015245386763633241518845356850979564402923266696704186567270006361208862086254527576010412135230279553684940635956656649728134893874567619948675304052482720430367748612708917105846534082863042823913166120865362252479206576942147071396319459112580853771742537940112457 >>> e = 56172436577459725698934391359139104915041430213184221292301658571726414059411889155782982024019814564512291421932489731563519296372873415080546379424619308859152360214209740169135159761234894923144971372974038021945201954600238994209605035703317119192844975463915465725406543097929017637859019950590916533609 >>> RSA . wiener_attack ( n , e ) ( 65537 , 7378976741566796197060049293831700178355367285954368722446941408821453416404178156616347704608205580844317832893779999699977892594442209725444425740109323 , 10507143770626084625372769867908090388836545006827124055843791486155727314389374863050474785111869163080974026305280302634065146526795980161236365076948859 )","title":"Wiener's Attack"},{"location":"RSA/utilities/","text":"RSA utilities Recover Prime Factors This function can be used to recover p and q given n, e, and d. Arguments: n:integer, e:integer, d:integer Returns: integer, integer (p, q); If primes not found, will return -1, -1 Example usage >>> n = 77531969503748326589677418948315140870584015245386763633241518845356850979564402923266696704186567270006361208862086254527576010412135230279553684940635956656649728134893874567619948675304052482720430367748612708917105846534082863042823913166120865362252479206576942147071396319459112580853771742537940112457 >>> e = 56172436577459725698934391359139104915041430213184221292301658571726414059411889155782982024019814564512291421932489731563519296372873415080546379424619308859152360214209740169135159761234894923144971372974038021945201954600238994209605035703317119192844975463915465725406543097929017637859019950590916533609 >>> d = 65537 >>> RSA . recover_prime_factors ( n , e , d ) ( 7378976741566796197060049293831700178355367285954368722446941408821453416404178156616347704608205580844317832893779999699977892594442209725444425740109323 , 10507143770626084625372769867908090388836545006827124055843791486155727314389374863050474785111869163080974026305280302634065146526795980161236365076948859 )","title":"Utilities"},{"location":"RSA/utilities/#rsa-utilities","text":"","title":"RSA utilities"},{"location":"RSA/utilities/#recover-prime-factors","text":"This function can be used to recover p and q given n, e, and d. Arguments: n:integer, e:integer, d:integer Returns: integer, integer (p, q); If primes not found, will return -1, -1 Example usage >>> n = 77531969503748326589677418948315140870584015245386763633241518845356850979564402923266696704186567270006361208862086254527576010412135230279553684940635956656649728134893874567619948675304052482720430367748612708917105846534082863042823913166120865362252479206576942147071396319459112580853771742537940112457 >>> e = 56172436577459725698934391359139104915041430213184221292301658571726414059411889155782982024019814564512291421932489731563519296372873415080546379424619308859152360214209740169135159761234894923144971372974038021945201954600238994209605035703317119192844975463915465725406543097929017637859019950590916533609 >>> d = 65537 >>> RSA . recover_prime_factors ( n , e , d ) ( 7378976741566796197060049293831700178355367285954368722446941408821453416404178156616347704608205580844317832893779999699977892594442209725444425740109323 , 10507143770626084625372769867908090388836545006827124055843791486155727314389374863050474785111869163080974026305280302634065146526795980161236365076948859 )","title":"Recover Prime Factors"},{"location":"lattice/utilities/","text":"Lattice utilities Gram Schmidt Uses the Gram-Schmidt algorithm to calculate the orthogonal basis of vectors. Arguments: v:[[integer]]; list of vectors Returns: [[integer]] which represents the orthogonal basis vectors Example usage >>> lattice . gram_schmidt ([[ 1 , 1 , 0 ], [ 2 , 2 , 3 ]]) [[ 1.0 , 1.0 , 0.0 ], [ 0.0 , 0.0 , 3.0 ]] Gaussian Lattice Reduction (Requires Sage) Applies the Guassian Lattice Reduction algorithm to find V s.t. ||V|| is minimized. Only works on 2 dimensions. Arguments: v1:vector, v2:vector; must be of length 2 Returns: vector, vector (v1, v2); where v1 is the shortest vector in L Example usage >>> v1 = vector ( ZZ , [ 1 , 1337 ]) >>> v2 = vector ( ZZ , [ 2 , 1237 ]) >>> lattice . gauss_lat_red ( v1 , v2 ) (( - 29 , 26 ), ( 14 , 37 ))","title":"Utilities"},{"location":"lattice/utilities/#lattice-utilities","text":"","title":"Lattice utilities"},{"location":"lattice/utilities/#gram-schmidt","text":"Uses the Gram-Schmidt algorithm to calculate the orthogonal basis of vectors. Arguments: v:[[integer]]; list of vectors Returns: [[integer]] which represents the orthogonal basis vectors Example usage >>> lattice . gram_schmidt ([[ 1 , 1 , 0 ], [ 2 , 2 , 3 ]]) [[ 1.0 , 1.0 , 0.0 ], [ 0.0 , 0.0 , 3.0 ]]","title":"Gram Schmidt"},{"location":"lattice/utilities/#gaussian-lattice-reduction-requires-sage","text":"Applies the Guassian Lattice Reduction algorithm to find V s.t. ||V|| is minimized. Only works on 2 dimensions. Arguments: v1:vector, v2:vector; must be of length 2 Returns: vector, vector (v1, v2); where v1 is the shortest vector in L Example usage >>> v1 = vector ( ZZ , [ 1 , 1337 ]) >>> v2 = vector ( ZZ , [ 2 , 1237 ]) >>> lattice . gauss_lat_red ( v1 , v2 ) (( - 29 , 26 ), ( 14 , 37 ))","title":"Gaussian Lattice Reduction (Requires Sage)"}]}